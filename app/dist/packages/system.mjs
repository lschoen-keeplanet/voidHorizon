import fs from"fs";import path from"path";import{BaseSystem}from"../../common/packages/module.mjs";import{PACKAGE_AVAILABILITY_CODES}from"../../common/constants.mjs";import{hasProperty,isEmpty,duplicate,mergeObject,isNewerVersion}from"../../common/utils/helpers.mjs";import ServerPackageMixin,{PackageAssetField}from"./package.mjs";export default class System extends(ServerPackageMixin(BaseSystem)){static defineSchema(){const e=super.defineSchema();return e.background=new PackageAssetField({relativeToPackage:!1,mustExist:!1,...e.background.options}),e}#e;#t=0;updateSource(e={},t={}){return"version"in e&&Object.defineProperty(this,"_template",{value:null,configurable:!0}),super.updateSource(e,t)}validate(e){return this.installed&&this.loadDataTemplate(this._source.id),super.validate(e)}loadDataTemplate(e=this.id){return this._template||Object.defineProperty(this,"_template",{value:System.#a(e),configurable:!0}),this._template}static#a(e){const t=path.join(this.baseDir,e,"template.json");if(!fs.existsSync(t))throw new Error(`The required "template.json" file does not exist for system ${e}`);try{return JSON.parse(fs.readFileSync(t,"utf-8"))}catch(t){throw new Error(`Unable to parse system template for ${e}: ${t.message}`)}}async getUpdateNotification(){const e=Date.now();if(!this.#e||e-this.#t>864e5){const e=await this.constructor.check(this.manifest,this);e.isUpgrade?globalThis.logger.info(`${this.title} update ${e.remote.version} is now available!`):globalThis.logger.info(`No system update for ${this.title} is currently available.`),this.#e={hasUpdate:e.isUpgrade,version:e.remote?.version||null}}return this.#e}async checkUpdateAvailable(){const e=await System.fromRemoteManifest(this.manifest);return isNewerVersion(e.version,this.version)&&e.availability<=PACKAGE_AVAILABILITY_CODES.UNVERIFIED_GENERATION?e.version:null}getDataModel(e){const t=this.loadDataTemplate();return Object.values(foundry.documents).filter((e=>e.hasTypeData)).reduce(((a,s)=>{const r=s.documentName,i=t.hasOwnProperty(r)?t[r]:{},o=!isEmpty(i);return a[r]=e[r].reduce(((e,t)=>{const a=o?duplicate(i[t]||{}):{};let s={},r=a.templates||[];r=r.filter((e=>hasProperty(i,`templates.${e}`)));for(let e of r)mergeObject(s,i.templates[e],{enforceTypes:!1});return delete a.templates,s=mergeObject(s,a,{inplace:!1,enforceTypes:!1}),e[t]=s,e}),{}),a}),{})}static async install(e,t,a,s,r){const i=await super.install(e,t,a,s,r);return packages.World.resetPackages(),i}static async uninstall(e){const t=await super.uninstall(e);return packages.World.resetPackages(),t}}