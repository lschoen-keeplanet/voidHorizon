import*as fs from"fs";import*as path from"path";import archiver from"archiver";import Files from"../files/files.mjs";import DataModel from"../../common/abstract/data.mjs";import*as fields from"../../common/data/fields.mjs";import{PackageCompatibility}from"../../common/packages/module.mjs";import BasePackage,{PackageRelationships}from"../../common/packages/base-package.mjs";import ProgressEmitter from"../components/progress-emitter.mjs";export default class PackageBackups{static BACKUP_TYPES=["module","system","world","snapshot"];createBackup(e,t,{level:a=6,note:s="",onProgress:i,snapshotId:r}={}){const{logger:n,packages:o}=global,{ACTIONS:c,STEPS:p}=CONST.SETUP_PACKAGE_PROGRESS,l=o.PACKAGE_TYPE_MAPPING[t].get(e);if(!l)throw new Error(`Cannot create a backup of ${t} '${e}' because it is not installed.`);const{backups:d,install:g}=this.#e(e,t);return fs.mkdirSync(d,{recursive:!0}),n.info(`Writing backup for ${t} '${e}'.`),new Promise((async(o,u)=>{const f=new Date,h=`${t}.${e}.${f.toDateInputString()}.${f.valueOf()}`,S=path.join(d,`${h}.bak`),k=path.join(d,`${h}.json`),P=fs.createWriteStream(S),m=archiver("zip",{zlib:a}),b=await Files.getDirectorySize(g),w=new ProgressEmitter(c.CREATE_BACKUP,p.ARCHIVE,b,{packageId:e,type:t,id:h},{onProgress:i});m.on("warning",(e=>n.warn(e))),m.on("error",(e=>u(e))),m.on("progress",(({fs:e})=>w.emit(e.processedBytes))),P.on("close",(()=>{const a=m.pointer();n.info(`Wrote backup for ${t} '${e}' to '${S}'. Wrote ${a} bytes.`),o(this.#t(l,k,{createdAt:f.valueOf(),id:h,size:a,note:s,snapshotId:r}))})),m.pipe(P),m.directory(g,!1),m.finalize()}))}async restoreBackup(e,{onProgress:t}={}){const{paths:a}=global,{id:s}=e,i=path.join(a.backups,"tmp",s);fs.mkdirSync(i,{recursive:!0});try{const a=await this.#a(e,i,{onProgress:t});await this.#s(e,i,a,{onProgress:t})}finally{fs.rmSync(i,{recursive:!0,maxRetries:10})}}listBackups(){const{paths:e,logger:t}=global,a=Object.keys(packages.PACKAGE_TYPE_MAPPING).reduce(((a,s)=>{a[s]={};const i=packages.PACKAGE_TYPE_MAPPING[s],r=path.join(e.backups,i.collection);if(!fs.existsSync(r))return a;for(const e of fs.readdirSync(r,{withFileTypes:!0})){if(!e.isDirectory())continue;const i=e.name;try{BasePackage.validateId(i)}catch(e){t.warn(`Invalid backup directory '${i}' found when listing backups: ${e.message}`);continue}a[s][i]=this.getBackups(i,s)}return a}),{});return a.snapshots=this.getSnapshots(),a}getBackups(e,t){const{logger:a}=global,{backups:s}=this.#e(e,t);if(!fs.existsSync(s))return[];const i=[];for(const e of fs.readdirSync(s))if(".json"===path.extname(e))try{const t=JSON.parse(fs.readFileSync(path.join(s,e),{encoding:"utf8"}));i.push(new BackupData(t))}catch(t){a.warn(`Found JSON file '${path.join(s,e)}' that was not a valid backup manifest: ${t.message}`)}return i}#a(e,t,{onProgress:a}={}){const{logger:s}=global,{ACTIONS:i,STEPS:r}=CONST.SETUP_PACKAGE_PROGRESS,{id:n,packageId:o,type:c}=e,{backups:p}=this.#e(o,c),l=path.join(p,`${n}.bak`);if(!fs.existsSync(l))throw new Error(`Backup for ${c} package '${o}' with ID '${n}' did not exist.`);let d,g;return s.info(`Extracting backup '${n}' for ${c} package '${o}'.`),Files.extractArchive(l,t,{onProgress:(e,t,s)=>{d=s,g||(g=new ProgressEmitter(i.RESTORE_BACKUP,r.EXTRACT,s,{packageId:o,type:c,id:n},{onProgress:a})),g.emit(t)}})}#s(e,t,a,{onProgress:s}={}){const{logger:i}=global,{ACTIONS:r,STEPS:n}=CONST.SETUP_PACKAGE_PROGRESS,{id:o,packageId:c,type:p}=e,{install:l}=this.#e(c,p);i.info(`Deleting existing installation at '${l}'.`),fs.rmSync(l,{force:!0,recursive:!0,maxRetries:10});let d=0;const g=new ProgressEmitter(r.RESTORE_BACKUP,n.INSTALL,a,{packageId:c,type:p,id:o},{onProgress:s});return i.info(`Copying backup files '${t}' -> '${l}'`),Files.copyDirectory(t,l,{onProgress:()=>g.emit(++d)})}#t(e,t,a={}){const s=new BackupData({...e.toObject(),...a,packageId:e.id,type:e.constructor.type});return fs.writeFileSync(t,JSON.stringify(s.toObject(),null,2),{encoding:"utf8"}),s}async createSnapshot({level:e=6,note:t="",onProgress:a}={}){const{logger:s,packages:i,paths:r}=global,{ACTIONS:n,STEPS:o}=CONST.SETUP_PACKAGE_PROGRESS,c=new Date,p=`snapshot.${c.toDateInputString()}.${c.valueOf()}`,l=path.join(r.backups,"snapshots"),d=path.join(l,`${p}.json`),g=[];let u=0;fs.mkdirSync(l,{recursive:!0}),s.info(`Taking snapshot '${p}'.`);for(const[t,r]of Object.entries(i.PACKAGE_TYPE_MAPPING)){s.info(`Snapshotting ${t}s.`);const i=o[`SNAPSHOT_${t.toUpperCase()}S`],c=new ProgressEmitter(n.CREATE_SNAPSHOT,i,r.packages.size,{id:p,type:"snapshot"},{onProgress:a});let l=0;for(const s of r.packages){const i=await this.createBackup(s.id,t,{level:e,onProgress:a,snapshotId:p});c.emit(++l),u+=i.size,g.push(i.id)}}return this.#i(d,{createdAt:c.valueOf(),size:u,id:p,note:t,backups:g})}async restoreSnapshot(e,{onProgress:t}={}){const{logger:a,paths:s}=global,{ACTIONS:i,STEPS:r}=CONST.SETUP_PACKAGE_PROGRESS,{id:n,backups:o,size:c}=e,p=new ProgressEmitter(i.RESTORE_SNAPSHOT,r.ERROR,1,{id:n,type:"snapshot"},{log:!1}),l=path.join(s.backups,"tmp",n);fs.mkdirSync(l,{recursive:!0}),await Files.checkDiskSpace(l,1.7*c);try{const e=[],s=new ProgressEmitter(i.RESTORE_SNAPSHOT,r.EXTRACT,o.size,{id:n,type:"snapshot"});for(const i of o)try{const a=this.#r(i);if(!a)throw new Error("Failed to read backup manifest.");const r=path.join(l,i);fs.mkdirSync(r,{recursive:!0});const n=await this.#a(a,r,{onProgress:t});e.push({backupData:a,totalFiles:n,extractDir:r}),s.emit(e.length)}catch(e){const[t,s]=i.split(".");throw e.message=`Failed to restore backup ID '${i}': ${e.message}`,a.error(e),p.emit(1,{force:!0,context:{packageId:s,packageType:t}}),e}let c=0;const d=new ProgressEmitter(i.RESTORE_SNAPSHOT,r.INSTALL,e.length,{id:n,type:"snapshot"});for(const{backupData:s,totalFiles:i,extractDir:r}of e)try{await this.#s(s,r,i,{onProgress:t}),d.emit(++c)}catch(e){throw e.message=`Failed to restore backup ID '${s.id}': ${e.message}`,a.error(e),p.emit(1,{force:!0,context:{packageId:s.packageId,packageType:s.type}}),e}}finally{fs.rmSync(l,{recursive:!0,maxRetries:10})}}getSnapshots(){const{logger:e,paths:t}=global,a=path.join(t.backups,"snapshots");if(!fs.existsSync(a))return{};const s={};for(const t of fs.readdirSync(a))if(".json"===path.extname(t))try{const e=JSON.parse(fs.readFileSync(path.join(a,t),{encoding:"utf8"})),i=new SnapshotData(e);s[i.id]=i}catch(s){e.warn(`Found JSON file '${path.join(a,t)}' that was not a valid snapshot manifest: ${s.message}`)}return s}#i(e,t={}){const{config:a}=global,{generation:s,build:i}=a.release,r=new SnapshotData({type:"snapshot",generation:s,build:i,...t});return fs.writeFileSync(e,JSON.stringify(r.toObject(),null,2),{encoding:"utf8"}),r}#r(e){const[t,a]=e.split(".");if(!t||!a)return;const{backups:s}=this.#e(a,t),i=JSON.parse(fs.readFileSync(path.join(s,`${e}.json`),{encoding:"utf8"}));return new BackupData(i)}#e(e,t){const{packages:a,paths:s}=global,i=a.PACKAGE_TYPE_MAPPING[t];return{install:path.join(i.baseDir,e),backups:path.join(s.backups,i.collection,e)}}}class BaseBackupData extends DataModel{static defineSchema(){return{type:new fields.StringField({required:!0,blank:!1,choices:PackageBackups.BACKUP_TYPES}),createdAt:new fields.NumberField({required:!0,integer:!0,positive:!0}),size:new fields.NumberField({required:!0,integer:!0,positive:!0}),note:new fields.StringField({required:!0})}}}class BackupData extends BaseBackupData{static defineSchema(){return Object.assign({},super.defineSchema(),{id:new fields.StringField({required:!0,blank:!1,validate:BackupData.validateBackupId}),packageId:new fields.StringField({required:!0,blank:!1,validate:BasePackage.validateId}),snapshotId:new fields.StringField({required:!0,blank:!1,nullable:!0,validate:SnapshotData.validateSnapshotId}),title:new fields.StringField({required:!0,blank:!1}),description:new fields.StringField({required:!0}),version:new fields.StringField({required:!0,blank:!1,initial:"0"}),compatibility:new PackageCompatibility,relationships:new PackageRelationships})}static validateBackupId(e){const{packages:t}=global,[,a,s]=e.match(/([a-z]+)\.([A-Z\d-_]+)\.\d{4}-\d\d-\d\d\.\d+/i)??[];if(!(a in t.PACKAGE_TYPE_MAPPING)||!s)throw new Error("Malformed backup identifier.");BasePackage.validateId(s)}}class SnapshotData extends BaseBackupData{static defineSchema(){return Object.assign({},super.defineSchema(),{id:new fields.StringField({required:!0,blank:!1,validate:SnapshotData.validateSnapshotId}),generation:new fields.NumberField({required:!0,nullable:!1,integer:!0,min:1}),build:new fields.NumberField({required:!0,nullable:!1,integer:!0}),backups:new fields.SetField(new fields.StringField({required:!0,blank:!1,validate:BackupData.validateBackupId}))})}static validateSnapshotId(e){if(!/snapshot\.\d{4}-\d\d-\d\d\.\d+/.test(e))throw new Error("Malformed snapshot identifier.")}}