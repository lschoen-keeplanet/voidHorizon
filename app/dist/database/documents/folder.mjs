import BaseFolder from"../../../common/documents/folder.mjs";import ServerDocumentMixin from"../backend/server-document.mjs";import{SORT_INTEGER_DENSITY}from"../../../common/constants.mjs";export default class Folder extends(ServerDocumentMixin(BaseFolder)){async getSubfolders(e=!1,t){if((t=t||new Set).has(this.id))return[];let o=await this.constructor.find({folder:this.id});if(t.add(this.id),e&&o.length)for(let e of o){const i=await e.getSubfolders(!0,t);o=o.concat(i)}return o}async _preCreate(e,t,o){if(!Number.isFinite(this.sort)){const e=await Folder.find({type:this.type});let t=Math.max(...e.map((e=>e.sort||0)));this.updateSource({sort:t+SORT_INTEGER_DENSITY})}if(e.folder){const t=e.pack?db.packs.get(e.pack).folders:db.Folder;let o=await t.get(e.folder);if(!o)return;const i=e.pack?CONST.FOLDER_MAX_DEPTH-1:CONST.FOLDER_MAX_DEPTH;let r=1;for(;o?.folder;)o=await t.get(o.folder),r++;if(r>=i)throw new Error(game.i18n.format("FOLDER.ExceededMaxDepth",{depth:i}))}if(this.compendium&&this.compendium.packData.type!==this.type)throw new Error(`Attempted to create a Folder for ${this.type} Documents in a compendium that only allows for ${this.compendium.packData.type} Documents.`);return super._preCreate(e,t,o)}async _preUpdate(e,t,o){if(await super._preUpdate(e,t,o),e.parent&&e.parent===this.id)throw new Error("You cannot assign a Folder to be it's own parent")}async _preDelete(e,t){const o=this.parent||null,{deleteContents:i,deleteSubfolders:r}=e,s=[],a=[],n=await this.getSubfolders(!0);for(let e of n)r?s.push(e.id):a.push(e.id);if(s.length&&(await this.constructor.sublevel.delMany(s),global.express.io.emit("modifyDocument",{request:{type:"Folder",action:"delete",pack:this.pack,options:e},result:s})),a.length&&(await this.constructor.sublevel.findUpdate({_id__in:Array.from(a)},{parent:o}),global.express.io.emit("modifyDocument",{request:{type:"Folder",action:"update",pack:this.pack,options:e},result:a.map((e=>({_id:e,folder:o})))})),"Compendium"===this.type)return;s.push(this.id);const d=this.pack?this.compendium.sublevel:db[this.type].implementation.sublevel;let l=[];if(i)l=await d.findDelete({folder__in:Array.from(s)}),l.length&&global.express.io.emit("modifyDocument",{request:{type:this.type,action:"delete",pack:this.pack,options:e},result:l.map((e=>e._id))});else{const t=await d.findUpdate({folder__in:Array.from(s)},{folder:o});t.length&&global.express.io.emit("modifyDocument",{request:{type:this.type,action:"update",pack:this.pack,options:e},result:t.map((e=>({_id:e._id,folder:o})))})}logger.info([`${vtt} | Deleting Folder [${this.id}] also deletes:`,s.length>1?s.length-1+" subfolders":"",l.length?`and ${l.length} ${this.type} documents`:""].filterJoin(" "))}}