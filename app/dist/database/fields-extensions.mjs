import*as fields from"../../common/data/fields.mjs";import LevelDatabase from"./backend/level-database.mjs";import{sanitizeFilePathField,sanitizeHTMLField}from"./sanitization.mjs";import EmbeddedDeltaMixin from"./backend/embedded-delta.mjs";fields.HTMLField.prototype.sanitize=sanitizeHTMLField,fields.FilePathField.prototype.sanitize=sanitizeFilePathField,Object.defineProperty(fields.EmbeddedCollectionDeltaField.prototype,"model",{get(){return EmbeddedDeltaMixin(this.element.implementation)},configurable:!0}),fields.EmbeddedCollectionField.prototype.expandEmbedded=async function(e,t,i,d){const{logger:a}=global,l=LevelDatabase.formatKey(i,this.name),o=d.sublevels[l],n=e[this.name];if(!Array.isArray(n))return a.warn(`Did not retrieve ${this.name} collection from ${this.model.documentName} ${e._id} as it was not an Array.`),[];const s=n.map((e=>LevelDatabase.formatKey(t,e))),m=await o.getMany(s),r=await Promise.all(m.reduce(((e,i)=>(i?._id&&e.push(this.model.expandEmbedded(i,{ldb:d,idPrefix:t,sublevelName:l})),e)),[])),b=m.length-r.length;return b&&a.warn(`${b} embedded ${this.name} records in ${this.model.documentName} ${e._id} were undefined and not retrieved from the ${l} sublevel.`),r},fields.EmbeddedCollectionField.prototype.batchWrite=function(e,t,i,d,{writeEmbedded:a=!0}={}){const{logger:l}=global,o=LevelDatabase.formatKey(d,this.name),n=e[this.name];return Array.isArray(n)?n.reduce(((e,d)=>(a&&this.model.batchWrite(d,t,{writeEmbedded:a,idPrefix:i,sublevelName:o}),e.push(d._id),e)),[]):(l.warn(`Did not write ${this.name} collection for ${this.model.documentName} ${e._id} as it was not an Array.`),[])},fields.EmbeddedCollectionField.prototype.batchDelete=function(e,t,i,d){const a=LevelDatabase.formatKey(d,this.name),l=e[this.name];for(const e of l??[])this.model.batchDelete(e,t,{idPrefix:i,sublevelName:a})},fields.EmbeddedCollectionField.prototype.batchDeleteBranch=function(e,t,i){const d=e.getEmbeddedCollection(this.name);for(const e of d)e.batchDelete(t,i)},fields.EmbeddedCollectionDeltaField.prototype.batchDeleteBranch=function(e,t,i){const d=e.getEmbeddedCollection(this.name);for(const a of d._source)d.isTombstone(a._id)?d.documentClass.batchDelete(a,t,{idPrefix:e.dbKey,sublevelName:LevelDatabase.formatKey(e.sublevelName,this.name)}):d.get(a._id).batchDelete(t,i)},fields.EmbeddedDocumentField.prototype.expandEmbedded=async function(e,t,i,d){const{logger:a}=global,l=LevelDatabase.formatKey(i,this.name),o=d.sublevels[l];let n=e[this.name];if(!n)return null;n=LevelDatabase.formatKey(t,n);const s=await o.get(n);return s?(await this.model.expandEmbedded(s,{ldb:d,idPrefix:t,sublevelName:l}),s):(a.warn(`Singleton embedded ${this.name} ${n} in ${this.model.documentName} ${e._id} was undefined and not retrieved from the ${l} sublevel.`),null)},fields.EmbeddedDocumentField.prototype.batchWrite=function(e,t,i,d,{writeEmbedded:a=!0}={}){const l=LevelDatabase.formatKey(d,this.name),o=e[this.name];return o?(a&&this.model.batchWrite(o,t,{writeEmbedded:a,idPrefix:i,sublevelName:l}),o._id):null},fields.EmbeddedDocumentField.prototype.batchDelete=function(e,t,i,d){const a=LevelDatabase.formatKey(d,this.name),l=e[this.name];l&&this.model.batchDelete(l,t,{idPrefix:i,sublevelName:a})};